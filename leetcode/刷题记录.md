# 灵茶基础算法精讲
## 两数之和
### 两数之和
链接： https://leetcode.cn/problems/two-sum/
解答
```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> index_map;
        
        for(int i=0;i< nums.size();i++){
            auto it = index_map.find(target- nums[i]);
            if(it != index_map.end()){
                return {it->second,i};
            }
            index_map[nums[i]] = i;
        }
        return {};
    }
};

```
注意这里使用了哈希表，it->second是获取键值对中的值。

## 两数之和 II
链接： https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/
解答
```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int l =0;
        int r = numbers.size()-1;
        while(l<r){
            int s = numbers[l]+numbers[r];
            if(s== target){
                return {l+1,r+1};
            }
            if(s < target){
                l++;
            }else{
                r--;
            }
        }
        return {};
    }
};
```

### 三数之和
链接： https://leetcode.cn/problems/3sum/description/

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        vector<vector<int>> ans;
        for(int i=0;i<nums.size()-2;i++){
            int x = nums[i];
            if(i>0 && (nums[i-1]==x)){
                continue;
            }
            if(x + nums[i+1]+nums[i+2]>0){
                break;
            }
            
            int j = i+1;
            int k = nums.size()-1;
            if(x + nums[k]+nums[k-1]<0){
                continue;
            }
            while(j<k){
                int s = x+nums[j]+nums[k];
                if(s >0){
                    k--;
                }else if(s<0){
                    j++;
                }else{
                    ans.push_back({nums[i],nums[j],nums[k]});
                    j++;
                    while(j<k &&(nums[j]== nums[j-1])){
                        j++;
                    }
                    k--;
                    while(j<k &&(nums[k] == nums[k+1])){
                        k--;  
                    }
                }
            }
        }
        return ans;  
    }
};
```
### 统计和小于目标的下标对数目
链接： https://leetcode.cn/problems/count-pairs-whose-sum-is-less-than-target/description/

```cpp
class Solution {
public:
    int countPairs(vector<int>& nums, int target) {
        int ans=0;
        sort(nums.begin(),nums.end());
        int l=0;
        int r = nums.size()-1;
        if(nums[l]+nums[l+1]>target){
            return 0;
        }
        while(l<r){
            int s= nums[l]+nums[r];
            if(s<target){
                ans= ans+(r-l);
                l++;    
            }else{
                r--;
            }
        }
        return ans;
    }
};
```
这里要思考的是ans的增加值，注意要先改变ans，再修改l的值。
### 最接近的三数之和
链接： https://leetcode.cn/problems/3sum-closest/description/

不要想的太复杂，就按照三数之和的思路解决，就可以，因为不需要找到下标，只要总和。
```cpp
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        sort(nums.begin(),nums.end());
        int ans= target;
        int last = 1e5;
        for(int i =0;i< nums.size()-2;i++){
            int x = nums[i];
            if(i>0 && x == nums[i-1]){
                continue;
            }
            int ts =x+ nums[i+1]+nums[i+2];
            if(ts > target){
                if(ts-target < last){
                    ans = ts;
                }
                break;
            }

            int j =i+1;
            int k = nums.size()-1;
            ts = x+nums[k]+ nums[k-1];
            if(ts < target){
                if(target-ts < last){
                    ans = ts;
                    last = target-ts;
                }
                continue;
            }
            while(j<k){
               
                int s = x+nums[j]+nums[k];
                if(s == target){
                    return target;
                }
                if(s > target){
                    if(s-target < last){
                        last = s- target;
                        ans = s;
                    }
                    k--;
                }else{
                    if(target-s <last){
                        last = target-s;
                        ans=s;
                    }
                    j++;
                }

            }
        }
        return ans;
        
    }
};
```

### 四数之和
链接： https://leetcode.cn/problems/4sum/
注意int类型的范围，可能越界。
三数之和迁移运用不太熟练，要多练习。
```cpp
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> ans;
        sort(nums.begin(),nums.end());
        if(nums.size()<4){
            return {};
        }
        int n = nums.size();
        for(int a=0;a<nums.size()-3;a++){
            long long  x= nums[a];
            if(a>0 && nums[a-1]==x){
                continue;
            }
            if(x+nums[a+3]+nums[a+1]+nums[a+2]>target){
                break;
            }
            if(x + nums[n-3] + nums[n-2] + nums[n-1] < target){
                continue;
            }
            for(int b=a+1;b<nums.size()-2;b++){
                if(b>a+1 && nums[b]==nums[b-1]){
                    continue;
                }
                long long  y = nums[b];
                if(x+y+nums[b+1]+nums[b+2]>target){
                    break;
                }
                
                int c  =b+1;
                int d = nums.size()-1;
                if(x+y+nums[d]+nums[d-1]<target){
                    continue;
                }
                while(c<d){
                    long long  s= x+y+nums[c]+nums[d];
                    if(s>target){
                        d--;
                    }else if(s<target){
                        c++;
                    }else{
                        ans.push_back({nums[a], nums[b], nums[c], nums[d]});
                        c++;
                        while(c<d && nums[c] == nums[c-1])
                            c++;
                        d--;
                        while(c<d && nums[d]==nums[d+1])
                            d--;
                    }       
                }       
            }
        }
        return ans;
    }
};

```

### 有效三角形的个数
链接 https://leetcode.cn/problems/valid-triangle-number/description/
这个题目，如果按照之前三数之和的正向逻辑无法做出来，之前可以枚举最小值，现在可以用枚举最大值的方式
```cpp
class Solution {
public:
    int triangleNumber(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        int ans =0;
        for(int k =2;k<nums.size();k++){
            int x = nums[k];
            int i=0;
            int j=k-1;
            while(i<j){
                if(nums[i]+nums[j]>x){
                    ans+= j-i;
                    j--;
                }else{
                    i++;
                }
            }
        }
        return ans;
        
    }
};
```

## 相向双指针
### 盛最多水的容器
链接：https://leetcode.cn/problems/container-with-most-water/
```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        int l = 0 ;
        int r = height.size()-1;
        int ans =0;
        while(l<r){
            int area=(r -l)* min(height[l],height[r]);
            ans = max(ans,area);
            if(height[l]<height[r]){
                l++;
            }else{
                r--;
            }
        }
        return ans;
        
    }
};
```

### 接雨水
链接： https://leetcode.cn/problems/trapping-rain-water/description/

解法一： 统计左右两边最高的高度，然后取最小值减去当前高度。这个思路还是很好的。
```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        vector<int> pre_max(n);
        vector<int> suf_max(n);
        pre_max[0]= height[0];
        suf_max[n-1]=height[n-1];
        for(int i=1;i<n;i++){
            pre_max[i]= max(pre_max[i-1],height[i]);
        }
        for(int i=n-2;i>-1;i--){
            suf_max[i] = max(suf_max[i+1],height[i]);
        }
        int ans=0;
        for(int i=0;i<n;i++){
            ans+= min(pre_max[i],suf_max[i])-height[i];
        }
        return ans;
        
    }
};
```

解法二：左右双指针,这个思想很巧妙，要多思考。

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        int ans =0;
        int pre_max=0;
        int suf_max=0;
        int l =0;
        int r=n-1;
        while(l<=r){
            pre_max = max(pre_max,height[l]);
            suf_max = max(suf_max,height[r]);
            if(pre_max<suf_max){
                ans+= pre_max-height[l];
                l++;
            }else{
                ans+= suf_max-height[r];
                r--;
            }
        }
        return ans;
        
    }
};
```
### 验证回文串
链接：https://leetcode.cn/problems/valid-palindrome/description/
这里的困难点在于string字符串相关api不熟悉，要加强学习。
```cpp
class Solution {
public:
    bool isPalindrome(string s) {
        bool res= true;
        
        string ts;
        for(char c : s){
            if(isalnum(c)){
                ts.push_back(tolower(c));
            }
        }
        int n = ts.size();
        int l=0;
        int r=n-1;
        while(l<r){
            if(ts[l] != ts[r]){
                res = false;
                return res;
            }else{
                l++;
                r--;
            }
        }
        return res;
    }
};
```

```cpp
class Solution {
public:
    bool isPalindrome(string s) {
        int n = s.size();
        int l=0;
        int r = n-1;
        bool res = true;
        while(l<r){
            if( !isalnum(s[l])){
                l++;
            }else if(!isalnum(s[r])){
                r--;
            }else if(tolower(s[l]) != tolower(s[r])){
                return false;
            }else{
                l++;
                r--;
            }
        }
        return true;
    }
};
```

### 给植物浇水 II
链接：https://leetcode.cn/problems/watering-plants-ii/description/
这个方法是0ms，内存80.4
```cpp
class Solution {
public:
    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {
        int ans=0;
        int n= plants.size();
        int l=0;
        int r=n-1;
        int waterA=capacityA;
        int waterB=capacityB;

        while(l<=r){
            if(l==r){
                if(plants[l]>max(waterA,waterB)){
                    ans+=1;
                }
                break;
            }
            if(plants[l]<= waterA && plants[r] <= waterB){
                waterA = waterA-plants[l];
                waterB = waterB - plants[r];
            }else{
                if(plants[l]<= waterA && plants[r]>waterB){
                    waterA = waterA-plants[l];
                    ans+=1;
                    waterB = capacityB;
                    waterB = waterB - plants[r];
                }else if(plants[l] > waterA && plants[r] <=waterB){
                    ans+=1;
                    waterA =capacityA;
                    waterA = waterA-plants[l];
                    waterB = waterB - plants[r];
                }else{
                    ans+=2;
                    waterA =capacityA;
                    waterA = waterA-plants[l];
                    waterB = capacityB;
                    waterB = waterB - plants[r];
                }
            }
            l++;
            r--;
        }
        return ans;
        
    }
};
```
这个方法3ms，内存80.4,但是更加简洁。
```cpp
class Solution {
public:
    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {
        int ans=0;
        int n= plants.size();
        int l=0;
        int r=n-1;
        int waterA=capacityA;
        int waterB=capacityB;
        while(l<r){
            if(plants[l] > waterA){
                ans+=1;
                waterA=capacityA;
            }
            waterA = waterA-plants[l];
            l++;
            if(plants[r]>waterB){
                ans+=1;
                waterB=capacityB;
            }
            waterB= waterB-plants[r];
            r--;  
        }
        if(l==r){
            if(plants[l]> max(waterA,waterB)){
                ans+=1;
            }
        }
        return ans;
        
    }
};
```

### 删除有序数组中的重复项
链接：https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/?envType=problem-list-v2&envId=two-pointers
这个思路还是很好想的。
```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n= nums.size();
        int l=0;
        int r=1;
        while(r<n){
            if(nums[l]== nums[r]){
                r++;
            }else{
                l+=1;
                nums[l] = nums[r];
                r++;
            }
        }
        return l+1;
        
    }
};
```

## 滑动窗口

### 长度最小的子数组
链接：https://leetcode.cn/problems/minimum-size-subarray-sum/description/ 

```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int n = nums.size();
        int l = 0;
        int ans= n+1;
        int s=0;
        for(int i=0;i<n;i++){
            s+=nums[i];
            while(s-nums[l]>=target){
                s-=nums[l];
                l++;
               
            }
            if(s>=target){
                ans=min(ans,i-l+1);
            }

        }
        return ans <= n ? ans:0;
    }
};
```

### 乘积小于 K 的子数组
链接：https://leetcode.cn/problems/subarray-product-less-than-k/description/

```cpp
class Solution {
public:
    int numSubarrayProductLessThanK(vector<int>& nums, int k) {
        if(k<=1){
            return 0;
        }
        int n= nums.size();
        int l=0;
        int ans =  0;
        long long s=1;
        for(int i=0;i<n;i++){
            s*= nums[i];
            while(s>=k){
                s/=nums[l];
                l++;
            }
            if(s< k){
                ans +=i-l+1;
            }
        }
        return ans;
        
    }
};
```

### 无重复字符的最长子串
链接：https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/
```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char,int> index_map;
        int ans=0;
        int n= s.size();
        int l=0;
        for(int i=0;i<n;i++){
            index_map[s[i]]+=1;
            while(index_map[s[i]]>1){
                index_map[s[l]]-=1;
                l++;
                
            }
            ans = max(ans,i-l+1);
        }
        return ans;
        
    }
};
```


## 链表

### 反转链表
链接： https://leetcode.cn/problems/reverse-linked-list/description/

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* pre=nullptr;
        ListNode* cur=head;
        while(cur){
            ListNode* nxt = cur->next;
            cur->next = pre;
            pre = cur;
            cur=nxt;
        }
        return pre;
        
    }
};

```

### 反转链表ii
链接：https://leetcode.cn/problems/reverse-linked-list-ii/

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        ListNode dummy(0, head);
        ListNode* p0 = &dummy;
        for(int i=0;i<left-1;i++){
            p0=p0->next;
        }
        ListNode* pre=nullptr;
        ListNode* cur= p0->next;
        for(int i=0;i<right-left+1;i++){
            ListNode* nxt = cur->next;
            cur->next=pre;
            pre=cur;
            cur=nxt;
        }
        p0->next->next = cur;
        p0->next=pre;
        return dummy.next; 
    }
};
```

### K个一组翻转链表
链接： https://leetcode.cn/problems/reverse-nodes-in-k-group/description/

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        int n=0;
        ListNode* cur =head;
        while(cur){
            n++;
            cur=cur->next;
        }
        ListNode dummy(0,head);
        ListNode* p0=&dummy;
        cur=p0->next;
        ListNode* pre=nullptr;
        while(n>=k){
            n-=k;
            for(int i=0;i<k;i++){
                ListNode* nxt= cur->next;
                cur->next= pre;
                pre=cur;
                cur=nxt;
            }
            ListNode* temp=p0->next;
            p0->next->next= cur;
            p0->next=pre;
            p0= temp;
            
        }
        return dummy.next; 
    }
};
```

### 两两交换链表中的节点
和上面一题是一样的，只不过K等于2而已

链接： https://leetcode.cn/problems/swap-nodes-in-pairs/
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode dummy(0,head);
        ListNode* p0=&dummy;
        int n=0;
        ListNode* cur= p0->next;
        while(cur){
            n++;
            cur=cur->next;
        }
        cur=p0->next;
        ListNode* pre = nullptr;
        int k=2;
        while(n>=k){
            n-=k;
            for(int i=0;i<k;i++){
                ListNode* nxt = cur->next;
                cur->next=pre;
                pre=cur;
                cur=nxt;
            }
            ListNode* temp =p0->next;
            p0->next->next = cur;
            p0->next= pre;
            p0= temp;
        }
        return dummy.next;
        
    }
};
```

### 两数相加 II
链接：https://leetcode.cn/problems/add-two-numbers-ii/
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
    ListNode* reverseList(ListNode* head){
        if(head == nullptr || head->next ==nullptr){
            return head;
        }
        ListNode* pre=nullptr;
        ListNode* cur=head;
        while(cur){
            ListNode* nxt = cur->next;
            cur->next=pre;
            pre= cur;
            cur=nxt;
        }
        return pre;
    }
    ListNode* addTwo(ListNode* l1, ListNode* l2){
        ListNode dummy;
        auto cur = &dummy;
        int carry =0;
        while(l1 || l2|| carry){
            if(l1){
                carry+=l1->val;
            }
            if(l2){
                carry+=l2->val;
            }
            cur->next= new ListNode(carry%10);
            cur= cur->next;
            carry/=10;
            if(l1){
                l1=l1->next;
            }
            if(l2){
                l2=l2->next;
            }
        } 
        return dummy.next;
    }

public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* res_l1=reverseList(l1);
        ListNode* res_l2= reverseList(l2);
        ListNode* l3=addTwo(res_l1,res_l2);
        return reverseList(l3);   
    }
};
```

### 两数相加
链接：https://leetcode.cn/problems/add-two-numbers/description/
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode dummy;
        auto l3 =&dummy;
        int carray =0;
        while(l1 || l2 || carray){
            if(l1){
                carray+=l1->val;
            }
            if(l2){
                carray+=l2->val;
            }
            l3->next = new ListNode(carray%10);
            l3=l3->next;
            carray/=10;
            if(l1){
                l1=l1->next;
            }
            if(l2){
                l2=l2->next;
            }
        }
        return dummy.next;
    }
};

```


### 翻倍以链表形式表示的数字
链接： https://leetcode.cn/problems/double-a-number-represented-as-a-linked-list/description/

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
    ListNode* reverse(ListNode* head){
        if(head==nullptr || head->next ==nullptr){
            return head;
        }
        ListNode* cur= head;
        ListNode* pre=nullptr;
        while(cur){
            ListNode* nxt= cur->next;
            cur->next=pre;
            pre=cur;
            cur=nxt;
        }
        return pre;
    }
public:
    ListNode* doubleIt(ListNode* head) {
        ListNode* cur= reverse(head);
        ListNode dummy;
        ListNode* ans=&dummy;
        int carray=0;
        while(cur || carray){
            if(cur){
                carray+= 2*cur->val;
            }
            ans->next= new ListNode(carray%10);
            carray/=10;
            ans= ans->next;
            if(cur){
                cur=cur->next;
            }
        }
        return reverse(dummy.next);
        
    }
};
```